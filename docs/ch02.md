---
layout: default
title: 第2章 为什么软件架构很重要？
nav_order: 3
---

# 第2章 为什么软件架构很重要？

>
> 啊，建造，建造！
> 这是所有艺术中最崇高的艺术。
>
> —Henry Wadsworth Longfellow

如果架构是答案，那么问题是什么？

本章从技术角度重点介绍架构的重要性。我们将研究十三个最重要的原因。你可以使用这些原因来鼓励创建新的架构，或分析和演进现有系统的架构。

1. 架构可以阻碍或实现系统驱动的质量属性。

2. 随着系统的演进，在架构中做出的决策允许你对变更进行论证和管理。

3. 通过对架构的分析来及早预测系统的质量。

4. 记录的架构增强了利益相关者之间的沟通。

5. 架构是设计决策最早的载体（carrier），因此也是最基本、最难改变的设计决策。

6. 架构定义了一组对后续实现的约束。

7. 架构决定了组织结构，反之亦然。

8. 架构可以为增量开发提供基础。

9. 架构是让架构师和项目经理论证成本和进度的关键产物。

10. 架构可以创建为可转移、可重用的模型，从而形成产品线的核心。

11. 基于架构的开发将注意力集中在组件的集成上，而不仅仅是它们的创建。

12. 通过限制设计备选方案，架构可以引导开发人员的创造力，降低设计和系统复杂性。

13. 架构可以成为培训团队新成员的基础。

即使你已经相信我们架构很重要，并且不需要再重复13次，也可以将这13点（本章的大纲）视为在项目中使用架构的13种有用方法，或者证明用于架构的资源是合理的。

## 2.1.阻碍或促成系统的质量属性

系统满足其所需（或所需）质量属性的能力在很大程度上取决于其架构。如果你不记得这本书的其他东西，请记住这一点。

这种关系是如此重要，以至于我们用了本书的整个 [第二部分][part02] 来详细阐述这些详细信息。在此之前，请记住以下示例作为起点：

- 如果你的系统需要高性能，那么你需要注意管理元素的：基于时间的行为、对共享资源的使用、以及元素间通信的频率和数量。

- 如果可修改性很重要，那么你需要注意为元素分配职责并限制这些元素的交互（耦合），以便对系统的大多数更改将只影响其中的一小部分元素。理想情况下，每个更改只会影响单个元素。

- 如果你的系统必须高度的信息安全，那么你需要管理和保护元素间通信，并控制允许哪些元素访问哪些信息。你可能还需要在架构中引入专用元素（例如授权机制），以设置强大的“边界（perimeter）”来防止入侵。

- 如果你希望你的系统安全可靠，你需要设计安全防护和恢复机制。

- 如果你认为性能的可伸缩性对系统的成功很重要，则需要使资源的使用本地化，以便于引入更高性能的替换，并且必须避免在资源假设或限制中进行硬编码。

- 如果你的项目需要能够增量交付系统的子集，则必须管理组件间的使用。

- 如果你希望系统中的元素在其他系统中可重用，则需要限制元素间耦合，以便在提取元素时，它不会在其当前环境中带出太多的附带元素而难以使用。

这些以及其他的质量属性的策略都是极其架构性的。但是，仅靠架构无法保证系统所需的功能或质量。糟糕的下游设计或实现决策总是会破坏合适的架构设计。正如我们喜欢说的（*主要是* 开玩笑）：架构给出的东西，实现可能会毁掉。生命周期各个阶段（从架构设计到编码实现到测试）的决策都会影响系统质量。因此，质量并不完全是架构设计的功能。但架构是质量的起点。

## 2.2.论证和管理变更

这是从上一点推论的。

可修改性——对系统进行更改的难易程度——是一个质量属性（因此在上一节的也涉及到了），但它是如此重要的品质，以至于我们在十三个列表中授予它自己的重要的地位。软件开发社区正在认识到这样一个事实，即典型软件系统总成本的大约 80% 发生在初始部署 *之后*。人们工作的大多数系统都处于这个阶段。许多程序员和软件设计师 *从不* 从事新的开发工作 —— 他们在现有架构和现有代码主体的约束下工作。几乎所有的软件系统在其生命周期内都会发生变化，以引入新功能、适配新环境、修复bug等等。但现实情况是，这些变化往往充满困难。

每个架构，无论它是什么，变更都可分为三类：局部的、非局部的和架构性的。

- 局部变更修改单个元素 (element)，比如，在定价模块中增加新的业务规则。

- 非局部变更需要修改多个元素 (element)，但是保持架构不变。比如，在定价模块增加新的业务规则，在数据库中为新的业务规则增加字段，并且在用户接口上呈现使用此规则的结果。

- 架构性变更则影响到元素(element)间交互的基本方式，并且可能会需要修改整个系统。比如，把系统从单线程变为多线程。

显然，本地更改是最期待的，因此在 *高效* 架构中局部变更是最常见的，它更易于进行。非局部变更并不那么期待，但它们通常还是可以有序进行的。例如，你可以先进行变更以添加新的定价规则，然后进行变更来实际部署新规则。

确定何时必须进行变更、确定哪些更改路径风险最小、评估建议变更的后果以及决定所请求变更的顺序和优先级，都需要对系统软件元素的关系、性能和行为有广泛的了解。这些任务都是架构师工作。对架构进行论证和分析可以提供对预期变更做出决策所需的见解。如果你不采取这一步，如果你不注意维护架构的概念完整性，那么你几乎肯定会积累*架构债务*。我们将在 [第23章][ch23] 中讨论这个主题。

## 2.3. 预测系统质量

这一点源自前两点：架构不仅赋予系统质量，而且以可预测的方式进行。

这似乎是显而易见的，但事实并非如此。然后设计一个架构将包括做出一系列几乎随机的设计决策，构建系统，测试质量属性，并希望得到最好的结果。糟糕 - 不够快或者太容易受到攻击？开始黑客攻击（？？？）。

幸运的是，*只要* 根据对系统架构的评估就可以对系统进行质量预测。如果我们知道某些类型的架构决策会导致系统中的某些质量属性，那么我们可以做出这些决策，并正确地预期可以获得相关的质量属性。当我们事后检查架构时，我们可以确定是否已做出这些决策，并自信地预测该架构将表现出相关的质量。

这一点和上一点加在一起，意味着架构在很大程度上决定了系统质量，甚至更好！我们知道它是如何做到的，我们知道如何让它做到这一点。

即使你有时不执行必须的定量分析建模，以确保架构将提供其规定的好处所，至少这种根据其质量属性含义评估决策的原则，对于及早发现潜在问题也是非常宝贵的。

## 2.4. 用于利益相关者间的沟通

[第1章][ch01] 中提出的一点是，架构是一种抽象，这很有用，因为它代表了整个系统的简化模型（与整个系统的无限细节不同），你可以把它记在脑海里。团队中的其他人也可以。架构代表了系统的常见抽象，大多数（如果不是全部）系统利益相关者都可以将其用作相互理解、协商、形成共识的基础，用于相互沟通。架构（或至少是其中的一部分）足够抽象，大多数非技术人员可以理解它，特别是在架构师的指导下，但这种抽象可以细化为足够丰富的技术规范来指导实现、集成、测试和部署。

软件系统的每个利益相关者（客户、用户、项目经理、编码人员、测试人员等）都关注受其架构影响的系统的不同特性部分。例如：

- 用户关心系统是否够快、可靠，在需要它的时候是可用的；

- 客户（为系统买单的人）关心架构能否按期被实现，能否满足预算；

- 项目经理关心（除了开支和计划）架构能否允许团队独立工作，且可控地、有条不紊地协作；

- 架构师则关心实现上述目标的策略。

架构提供了一种通用语言，在这种语言中，可以让人们在智力上可及的级别上表达、协商和解决不同的问题，即使在大型复杂系统中。如果没有这样的语言，就很难充分理解大型系统，从而做出影响质量和实用性的早期决策。架构分析，正如我们将在 [第21章][ch21] 中看到的，既依赖于这种层面上的沟通，又可以增强它。

关于架构文档的 [第22章][ch22]，更深入地讨论了利益相关者及其关注的问题。

> **“当我按下这个按钮时会发生什么？”：架构作为利益相关者沟通的工具**
>
> 项目评审喋喋不休。政府资助的开发项目落后于计划并超出预算，而且规模足够大，以至于这些失误引起了美国国会的注意。现在，政府正在通过举行马拉松式的“来者不拒”的评审会议来弥补过去的疏忽。承包商最近进行了收购，这无济于事。这是第二天下午，议程要求介绍软件架构。这位年轻的架构师（是该系统首席架构师的学徒），他勇敢地解释了这个庞大系统的软件架构如何使其能够满足其非常苛刻的实时、分布式、高可靠性要求。他扎实地介绍了一个扎实的架构。这是合理和明智的。但听众——大约30名政府代表，他们在管理和监督这个棘手的项目方面扮演着不同的角色——却觉得很疲惫。他们中的一些人甚至想，也许他们应该进入房地产行业，而不是忍受这种"一次搞定一切"都马拉松式的评审会议。
>
> 幻灯片以半正式的框线表示法显示了系统运行时视图中的主要软件元素。这些名字都是首字母缩略词，如果没有解释就没有语义意义，这是这位年轻的架构师给出的。线条表示数据流、消息传递和进程同步。正如架构师所解释的，这些元素在内部是冗余的。“如果发生失效，”他开始用激光笔指着其中一条线，“当......时，重启机制将会沿着这条路径触发”
>
> “按下模式选择按钮会发生什么？”一位听众打断了他。他是代表该系统用户社区的政府与会者。
>
> “能否再说一遍？”架构师问。
>
> “模式选择按钮，”他说。“你按下它的时候会怎么样？”
>
> “嗯，这会触发设备驱动程序中的一个事件，在这里，”架构师开始用激光笔指向那里。“然后，它读取寄存器并解析事件代码。如果是模式选择，那么，它会向黑板发出信号，黑板又会向订阅该事件的对象发出信号。
>
> “不，我的意思是系统*做什么*，”提问者打断了他。“它会重置显示吗？如果在系统重新配置期间发生这种情况，会怎么样？
>
> 架构师看起来有点惊讶，移开激光笔。这不是一个架构问题，但因为他是一名架构师，熟悉需求，所以他知道答案。“如果命令行处于设置模式，显示将会重置，”他说。“否则，控制台上会显示一条错误消息，但信号将被忽略。”他又重新把激光笔指回去。“现在，回到我刚才说的重启机制......”
>
> “嗯，我只是想知道，”用户代表说。“因为我从你的图表中看到，显示控制台正在向目标位置模块发送信号流。”
>
> “*应该* 发生什么？”另一位听众向第一个提问者问道。“你真的希望用户在重新配置期间获取模式数据吗？”在接下来的45分钟里，架构师看着观众通过辩论系统在各种深奥状态下的正确行为来占用他的时间——这是绝对必要的对话，它应该在制定需求时发生，但不知出于何种原因而没有进行。
>
> 辩论不是关于架构的，但架构（及其图示）引发了争论。很自然地将架构视为除了架构师和开发人员之外的一些利益相关者之间沟通的基础：例如，经理使用架构来组建团队并在他们之间分配资源。但是用户呢？毕竟，架构对用户来说是不可见的；他们为什么要把它作为理解系统的工具？
>
> 事实是他们这样做了。在这种情况下，提问者已经看了两天的幻灯片了，所有关于功能、操作、用户界面和测试。但这是关于架构的第一张幻灯片——尽管他很累，想回家——他还是意识到自己还有不明白的地方。参加许多架构评审使我确信，以一种新的方式看待系统会刺激思维并让新的问题浮上水面。对于用户来说，架构通常是这种新方式，用户提出的问题也是很自然的。在几年前一次令人难忘的架构评估练习中，用户代表对系统将要做什么比对它将如何做更感兴趣，这自然如此。在此之前，他们与供应商的唯一联系是通过其营销人员。架构师是他们可以接触到的第一个真正意义上的系统专家，他们毫不犹豫地抓住了机会。
>
> 当然，仔细和彻底的需求规范可以改善这种情况，但由于各种原因，需求并不总是被创建或是可用的。在没有需求的情况下，架构规范通常会引出问题并改善清晰度。需要谨慎地认识到这种可能性，而不是抵制它。
>
> 有时，这种做法会揭示不合理的需求，然后可以重新审视其效用。这种类型的评审强调需求和架构之间的协同作用，可以让我们故事中的年轻架构师摆脱困境，让他在整个评审会议中占有一席之地来处理这类信息。用户代表不会觉得自己像一条离水的鱼，在一个明显不合适的时刻提出他的问题。
>
> —PCC

## 2.5. 早期的设计决策

软件架构体现了系统最早期的设计决策，这些早期的设计决策对于系统的接下来的开发、部署和维护将产生巨大的影响。这也是最早可以仔细检查这些影响系统的重要设计决策的时间点。

任何学科的任何设计都可以被视为一系列决策。在画画时，艺术家甚至在画面开始之前就决定了画布的材质和画画的材料——油画、水彩、蜡笔。一旦开始作画，就会立即做出其他决策：第一条线在哪里，它的粗细是多少，它的形状是什么？所有这些早期设计决策都会对画面的最终结果产生很大的影响，每个决策都会限制随后的许多决策。单独来看，每个决策可能看起来都很无关紧要，但特别是早期的决策却具有不成比例的重要性，因为它们影响和限制了接下来的大部分决策。

架构设计也是如此。架构设计也可以被视为一组决策。改变这些早期决策将引起连锁反应，意味着后续的很多决策都需要跟着变更。是的，有时架构必须重构或重新设计，但这不是个轻而易举的任务——因为“涟漪”可能会变成雪崩。

软件架构体现的这些早期设计决策是什么？考虑：

- 系统是在一个处理器上运行还是分布在多个处理器上？

- 软件会分层吗？如果是这样，将有多少层？每一层分别做什么？

- 组件是同步通信还是异步通信？它们是传输控制还是数据，还是两者都有？

- 系统传递的信息是否会加密？

- 将使用哪种操作系统？

- 将选择哪种通信协议？

想象一下，必须改变这些或无数其他相关决定，那将会是一场噩梦。像这样的决策开始具化架构的一些结构和交互。

## 2.6. 约束实现

如果希望你的实现符合架构，则它必须符合架构规定的设计决策。它必须具有架构规定的一组元素，这些元素必须以架构规定的方式进行交互，并且每个元素必须履行对架构规定的其他元素的责任。这些规定中的每一个都是对实现者的约束。

元素构建者必须非常熟悉各个元素的规范，但他们可能没有意识到架构权衡 - 架构（或架构师）只是以一种满足权衡的方式约束它们。一个典型的例子是，当架构师将性能预算分配给某些较大功能中涉及的软件部分时。如果每个软件单元都在其预算范围内，则整个事务将满足其性能要求。每个组成部分的实现者可能不知道总体预算，而只知道他们自己的预算。

相反，架构师不必是算法设计专家或精通复杂的编程语言——尽管他们应该有足够的相关知识，来避免设计出难以构建的东西。然而，架构师是负责建立、分析和执行架构决策和权衡的人。

## 2.7. 影响组织架构

架构不仅规定了正在开发的系统的结构，而且该结构也烙进了对应的开发项目的结构中（有时是整个组织的结构）。在大型项目中分配人力的正常方法是将系统的不同部分分配给不同的组来构建。系统的这种所谓的工作分解结构体现在 [第1章][ch01] 中描述的架构中的工作分配结构。由于架构包括最广泛的系统分解，因此通常将其用作工作分解结构的基础。工作分解结构反过来决定了计划、进度表和预算的单元；团队间沟通渠道；配置控制和文件系统的组织；集成和测试计划和流程；甚至是项目细节，例如项目内部网的组织方式以及在公司野餐时谁与谁坐在一起。团队根据其元素的接口规范相互沟通。启动维护活动时，还将反映软件结构，并组建团队来维护架构中的特定元素 - 数据库、业务规则、用户界面、设备驱动程序等。

建立工作分解结构的副作用是冻结软件架构的某些方面。负责其中一个子系统的组可能会拒绝将其职责分配给其他组。如果这些职责已经写进合同，那么改变职责可能会变得昂贵甚至会引发诉讼。

因此，一旦就架构达成一致，出于管理和业务原因，对其进行重大修改的成本就会变得非常昂贵。这是先分析大型系统的软件架构，再确定具体选择的一个理由（众多理由之一）。

## 2.8. 使能增量开发

一旦定义了架构，它就可以作为增量开发的基础。第一个增量可以是框架系统，其中至少存在一些基础结构（元素初始化、通信、共享数据、访问资源、报告错误、日志活动等），但不存在系统的大部分应用功能。

构建基础结构和构建应用程序功能可以齐头并进。设计和构建一些基础设施来支持一些端到端功能；反复进行直到完成。

许多系统构建为可以使用插件、包或扩展进行扩展的骨架系统。例如：R 语言、Visual Studio Code 和大多数 Web 浏览器。添加扩展后，可以在框架中存在的功能外提供其他功能。这种方法通过确保系统在产品生命周期的早期就是可执行的来辅助开发过程。随着扩展的添加，或者软件的早期版本被该部分更完整版本替换，系统会越来越准确。在某些情况下，软件模块可能是低保真版本或最终功能的原型；在其他情况下，它们可能是*代理*，以适当的速率消费和产生数据，但几乎没有其他作用。此外，还允许在产品生命周期的早期，识别出潜在的性能（和其他）问题。

这种做法在 2000 年代初通过 Alistair Cockburn 的想法和他的“行走骨架（walking skeleton）”概念引起了人们的关注。最近，它已被那些采用MVP（最小可行产品（minimum viable product））作为降低风险的策略的人采用。

增量开发的好处包括降低项目中的潜在风险。如果架构适用于一系列相关系统，则可以在整个系列中重用基础设施，从而降低每个系统的成本。

## 2.9. 成本和进度估算

成本和进度估算是项目经理的重要工具。他们帮助项目经理获得必要的资源并监控项目进度。架构师的职责之一是帮助项目经理在项目生命周期的早期创建成本和进度估算。自上而下的估算对于设定目标和分摊预算很有用，但基于对系统各个部分的自下而上理解的成本估算，通常比纯粹基于自上而下的系统知识的成本估算更准确。

正如我们所说，项目的组织和工作分解结构几乎总是基于其架构。负责工作项的每个团队或个人将能够比项目经理更准确地估计他们的工作，并且在实现这些估计时会感到更多的所有权。但是，最佳的成本和进度估算通常来自——自上而下的估算（由架构师和项目经理创建）和自下而上的估算（由开发人员创建）之间的共识。这个过程讨论和谈判带来的结果比单独使用任何一种方法都更准确。

如果对系统的需求进行评审和验证会很有帮助。在前期对范围了解越多，对成本和进度的估算就越准确。

[第24章][ch24] 深入探讨了架构在项目管理中的使用。

## 2.10. 可转换、可重用的模型

在生命周期中越早应用重用，从这种做法中获得的好处就越大。虽然代码重用提供了好处，但架构的重用为具有类似需求的系统提供了巨大的帮助。当架构决策可以跨多个系统重用时，我们在前面部分中描述的所有早期决策结果也会转移到这些系统中。

产品线或产品系列是一组系统，它们都是使用同一组共享资产（软件组件、需求文档、测试用例等）构建的。这些资产中最主要的是旨在满足整个系列需求的架构。产品线架构师选择一个架构（或一系列密切相关的架构），该架构将为产品线的所有的预想成员提供服务。该架构定义了产品线所有成员的固定内容以及可变内容。

产品线代表了一种强大的多系统开发方法，在上市时间、成本、生产力和产品质量方面都显示出数量级的回报。架构的力量是这种范式的核心。与其他资本投资类似，产品线的架构成为组织的共享资产。

## 2.11. 架构允许合并独立开发的元素

早期的软件范式侧重于把 *编程（programming）* 作为主要活动，进度以代码行来衡量，而基于架构的开发通常侧重于 *组合（composing）* 或*组装元素（assembling elements）*，这些元素可能是单独开发的，甚至彼此之间是独立的。这种组合是可能的，因为架构定义了可以合并到系统中的元素。该架构根据它们与环境的交互方式、接收和放弃控制的方式、使用和生成哪些数据、如何访问数据以及用于通信的协议和资源共享，来限制可能的替换（或添加）。我们在 [第15章][ch15] 中详细阐述了这些想法。

商业现成组件、开源软件、公开可用的应用程序和网络服务都是独立开发的元素的例子。将许多独立开发的元素集成到系统中的复杂性和普遍性催生了整个软件工具行业，例如Apache Ant，Apache Maven，MSBuild和Jenkins。

对于软件，回报可能有以下形式：

- 缩短上市时间（使用别人的现成解决方案应该比构建自己的解决方案更容易。

- 提高可靠性（广泛使用的软件应该已经解决了bug）。

- 降低成本（软件供应商可以分散其客户群的开发成本。

- 灵活性（如果你想购买的元素不是非常特殊，则可能从多个来源获得，这反过来又增加了你的购买筹码）。

*开放系统（open system）* 是为软件元素定义一套标准的系统，即它们的行为方式、与其他元素的交互方式、共享数据的方式等等。开放系统的目标是使（甚至鼓励）许多不同的供应商能够生产元素。这可以避免“单一厂商限制”，即单个供应商是唯一可以提供元素并为此收取高价的供应商。开放系统由定义元素及其交互的架构来实现的。

## 2.12. 限制备选设计的词汇

随着有用的架构解决方案的收集，很明显，尽管软件元素可以或多或少以无限的方式组合，但自觉地将我们自己限制在，相对较少的元素选择及其交互中，可以获得一些好处。如此，我们可以最大限度地减少正在构建的系统设计的复杂性。

软件工程师不是创意和自由至上的 “*艺术家（artiste）*”。相反，工程学是关于纪律的，而纪律则部分是通过将替代方案的词汇 *限制（restricting）* 在经过验证的方案来实现的。这些经过验证的设计方案的示例包括策略和模式，这将在 [第二部分][part02] 中广泛讨论。重用现成的元素是限制设计词汇量的另一种方法。

将设计词汇限制为经过验证的方案可以带来以下好处：

- 增强的重用

- 更规则、更简单的设计，更容易理解和沟通，并带来更可靠的可预测结果

- 分析起来更轻松，更可信

- 更短的选择时间

- 更好的互操作性

前所未有的设计是有风险的。经过验证的设计是经过验证的。这并不是说软件设计永远不可能是创新的，或者提供新的和令人兴奋的解决方案。当然可以。但是，这些解决方案不应该为了新颖而发明；相反，只有当现有解决办法不足以解决手头的问题时，才应该寻求这些办法。

软件的属性取决于架构策略或模式的选择。适用于特定问题的策略和模式应该能够改进生成的设计方案，可能是通过更容易地仲裁相互冲突的设计约束，通过增加对理解不足的设计上下文的洞察力，以及通过帮助发现需求中的不一致。我们将在 [第二部分][part02] 中讨论架构策略和模式。

## 2.13. 培训的基础

架构（包括对元素如何相互交互以执行所需行为的描述）可以作为新项目成员关于系统的第一堂课。这强化了我们的观点，即软件架构的一个重要用途是支持和鼓励各个利益相关者之间的沟通。架构是所有这些人的共同参考点。

模块视图是向人们展示项目结构的绝佳方式：谁做什么，哪些团队被分配到系统的哪些部分，等等。组件和连接视图是解释系统预期如何工作和完成其工作的绝佳选择。分配视图向新项目成员展示其分配的部分对应到项目中的哪些开发或部署环境。

## 2.14. 小结

由于各种技术和非技术原因，软件架构很重要。我们列了13条好处：

1. 架构将阻碍或促成系统的驱动质量属性。

2. 在架构中做出的决策允许你随着系统的发展对更改进行论证和管理。

3. 对架构的分析可以及早预测系统的质量。

4. 记录的架构增强了利益相关者之间的沟通。

5. 架构是设计决策最早的载体，因此也是最基本、最难改变的设计决策。

6. 架构定义了一组对后续实现的约束。

7. 架构决定了组织的结构，反之亦然。

8. 架构可以为增量开发提供基础。

9. 架构是允许架构师和项目经理论证成本和进度的关键工件。

10. 架构可以创建为可转移、可重用的模型，成为产品线的核心。

11. 基于架构的开发将注意力集中在组件的组装上，而不仅仅是它们的创建。

12. 通过限制设计备选方案，架构可以有效地引导开发人员的创造力，降低设计和系统复杂性。

13. 架构可以成为培训新团队成员的基础。

## 2.15. 扩展阅读

Gregor Hohpe的 *The Software Architect Elevator: Redefining the Architect’s Role in the Digital Enterprise* 描述了架构师与组织内外各级人员互动并促进利益相关者沟通的独特能力[[Hohpe 20][ref_116]]。

关于架构和组织的论文的鼻祖是[[Conway 68][ref_69]]。Conway定律指出，“设计系统的组织......被迫生产设计，这些设计是这些组织通信结构的副本。

Cockburn关于行走骨架（walking skeleton）的概念在 *Agile Software Development: The Cooperative Game* [[Cockburn 06][ref_68]]中进行了描述。

开放系统架构标准的一个很好的例子是为汽车行业开发的AUTOSAR（[autosar.org](http://autosar.org/))。

有关构建软件产品线的综合处理，请参阅 [[Clements 16][ref_66]]。基于功能的产品线工程是一种以自动化为中心的现代方法来构建产品线，将范围从软件扩展到系统工程。一个很好的总结可以在[[INCOSE 19][ref_127]] 找到。

## 2.16. 问题讨论

**1.** 如果你不记得这本书的其他东西，请记住......什么？没偷看可得加分。

**2.** 对于本章中阐述的架构很重要的13个原因中的每一个，请采取相反的立场：提出一系列不需要架构来实现所指示结果的情况。证明你的立场。（尝试为13个原因中的每个原因提出不同的情况。）

**3.** 本章认为架构带来了许多切实的好处。你如何衡量特定项目上13个点中每个点的收获？

**4.** 假设你要向组织引入以架构为中心的实践。你的管理层对这个想法持开放态度，但想知道这样做的投资回报率。你会如何回应？

**5.** 根据对你有意义的一些标准，确定本章中 13 个原因列表的优先级。证明你的答案。或者，如果你只能选择两三个原因来促进在项目中使用架构，你会选择哪个，为什么？

------

[part02]: part02.md

[ch01]: ch01.md
[ch15]: ch15.md
[ch21]: ch21.md
[ch22]: ch22.md
[ch23]: ch23.md
[ch24]: ch24.md

[ref_66]: ref01.md#ref_66
[ref_68]: ref01.md#ref_68
[ref_69]: ref01.md#ref_69
[ref_116]: ref01.md#ref_116
[ref_127]: ref01.md#ref_127
